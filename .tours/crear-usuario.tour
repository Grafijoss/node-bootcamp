{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Crear usuario",
  "steps": [
    {
      "file": "models/User.js",
      "description": "## Importamos Schema y model desde mongoose\r\n`User.js line: 1`\r\n\r\n- El schema es el contrato que va a tener la entidad en la base de datos\r\n\r\n",
      "line": 2
    },
    {
      "file": "models/User.js",
      "description": "## Schema\r\n*User.js line: 3*\r\n\r\n- Creamos uns schema con las propiedades que va a tener el contrato de **User**\r\n- Identificamos de que tipo va a ser cada propiedad\r\n-- Notes: va a ser un Array con todos los id de las notas que va aser de tipo **objectId**\r\n-- type: *Schema.Types.ObjectId*\r\n-- ref: La referencia es al modelo *Note* la relación la vamos a tener en los dos modelos\r\n\r\n## mongoose-unique-validator\r\n\r\n- Se puede validar que los campos del schema sean unicos para eso tienen que ser un objejeto y aladir el campo unique en true\r\n\r\n````javascript\r\nusername: {\r\n    type: String,\r\n    unique: true\r\n  }\r\n````\r\n\r\n- Se añade al schema el plugin de esta forma le añade al schema la funcionalidad de validar que los compos sean unicos\r\n\r\n````javascript\r\nuserSchema.plugin(uniqueValidator)\r\n````",
      "line": 4,
      "selection": {
        "start": {
          "line": 27,
          "character": 1
        },
        "end": {
          "line": 27,
          "character": 35
        }
      }
    },
    {
      "file": "models/User.js",
      "description": "## toJSON\r\n*User.js line: 13*\r\n\r\n- Con el toJSON podemos transformar los datos de entrada antes de recibirlos en el endpoint\r\n- Para el caso de User vamos a borrar el passwordHash por que es información sensible que no debe ser revelada\r\n",
      "line": 13
    },
    {
      "file": "models/Note.js",
      "description": "## Relación con el modelo User\r\n*User.js line: 7*\r\n\r\n-- user: va a ser un Object de tipo **objectId**\r\n-- type: *Schema.Types.ObjectId*\r\n-- ref: La referencia es al modelo *User* la relación la vamos a tener en los dos modelos",
      "line": 7
    },
    {
      "file": "models/User.js",
      "description": "## Instancia User de model\r\n*User.js line: 23*\r\n\r\n- Creamos una instancia de model\r\n- Recibe como primer parametro el nombre del moelo\r\n- Como segundo parametro el schema que va usar el modelo\r\n- De esta forma ya podemos usar el modelo para crear usuarios",
      "line": 23
    },
    {
      "file": "package.json",
      "description": "## Dependencia bcrypt\r\n*package.json line: 24*\r\n\r\n- npm install bcrypt\r\n- Va a hashear la contraseña en una sola dirección\r\n- es agnostico al lenguaje\r\n- que una encriptación sea mas segura depende del tiempo que ocupa hashear el password\r\n\r\n## Otras librerias para hashear passwords\r\n\r\n- MD5 (no es seguro)\r\n- SHA-2: resomendable precio coste \r\n\r\n",
      "line": 24
    },
    {
      "file": "controllers/users.js",
      "description": "## bcrypt hash\r\n*users.js*\r\n\r\n````javascript\r\nconst passwordHash = bcrypt.ha(password, saltRounds)\r\n````\r\n- primer parametro recibe el password que se va a hashear\r\n- segundo parametro saltRounds\r\n- hash: es el metodo asincrono\r\n- hashSync: es el metodo sincrono\r\n- Es recomendable usar hash porque el coste de computación que pueda tomar es grande entre mas complejo toma mas tiempo  ",
      "line": 20,
      "selection": {
        "start": {
          "line": 10,
          "character": 3
        },
        "end": {
          "line": 10,
          "character": 55
        }
      }
    },
    {
      "file": "controllers/users.js",
      "description": "## saltRounds\r\n\r\n*users.js*\r\n````javascript\r\nconst saltRounds = 10\r\n````\r\n\r\n- Es la complejidad algoritmica\r\n- Entre mas complejo mas tarda pero es mas seguro\r\n- Es el coste de computación que va tomar hashear el password",
      "line": 19,
      "selection": {
        "start": {
          "line": 15,
          "character": 6
        },
        "end": {
          "line": 15,
          "character": 27
        }
      }
    },
    {
      "file": "tests/user.test.js",
      "description": "## Test para probar la creación de un usuario\r\n\r\n*user.test.js*\r\n\r\n- Llamamos todos los usuarios desde helpers\r\n\r\n````javascript\r\nconst usersAtStart = await getUsers()\r\n````\r\n\r\n- Creamos el post desde el api\r\n- expect status 201\r\n- expecto Content-Type\r\n- llamamos a todos los usuarios antes y despues de rear el usuario\r\n- probamos la longitud\r\n- creamos un nuevo array con los username de los usuarios\r\n- probamos que existe el username de newUser en el arreglo de usernames\r\n",
      "line": 20,
      "selection": {
        "start": {
          "line": 33,
          "character": 16
        },
        "end": {
          "line": 33,
          "character": 28
        }
      }
    },
    {
      "file": "tests/user.test.js",
      "description": "## Probamos que no se pueda crear un usuario si el username esta repetido en la base de datos\r\n\r\n*user.test.js*\r\n\r\n````javascript\r\nexpect(result.body.errors.username.message).toContain('`username` to be unique')\r\n````\r\n\r\n- con mongoose-unique-validator podemos validar que un campo no este repetido desde el schema del modelo\r\n- dentro del body debe existir un campo de errores con el nombre del campo repetido y un mensaje con el error",
      "line": 43,
      "selection": {
        "start": {
          "line": 56,
          "character": 5
        },
        "end": {
          "line": 56,
          "character": 85
        }
      }
    }
  ]
}